#!/usr/bin/env bash

verbose=

error() {
  echo "$*" >&2
  exit 1
}

usage_error() {
  [ "$#" -gt 0 ] && echo "$*" >&2
  usage
  exit 1
}

verbose() {
  [ -n "$verbose" ] || return
  echo "$*" >&2
}

usage() {
  cat >&2 <<EOF
Usage: $(basename "$0") [OPTIONS] [SEARCH] [-- [SSH_OPTS]]

SSH to an AWS EC2 instance by Name tag. SEARCH can be a host Name tag or
substring. If SEARCH is omitted, all hosts will be selected.

  essh web

OPTIONS
  -c|--choose        Chose the given number instead of showing choices
  -d|--private       Use private DNS name
  -D|--public        Use public DNS name
  -h|--help          Show this help message
  -l|--list          Force showing the list even for only 1 option
  -n|--host-only     Print the host name instead of sshing to the host
  -p|--profile       An AWS CLI configuration profile. Multiple allowed.
  -r|--region        An AWS region. Multiple allowed.
  -R|--all-regions   Search all AWS regions. Overrides -r.
  -u|--user          An ssh login user
  -v|--verbose       Show verbose messages
  --                 If given, any options after it are sent to ssh
EOF
}

getopt -T && error 'GNU getopt required. Legacy getopt not supported.'

# Parse options with getopt
options="$(getopt \
  -o 'c:dDhlnp:r:Ru:v' \
  --long 'choose:,private,public,help,list,host-only,profile,region,all-regions,user:verbose' \
  -n "$(basename "$0")" \
  --quiet \
  -- "$@" \
)"
eval set -- "$options"

while true; do
  case "$1" in
    -c|--choose)
      choose="$2"; shift 2 ;;
    -d|--private)
      dns_type=private; shift 1 ;;
    -D|--public)
      dns_type=public; shift 1 ;;
    -h|--help)
      usage && exit ;;
    -l|--list)
      list=1; shift 1 ;;
    -n|--host-only)
      host_only=1; shift 1 ;;
    -p|--profile)
      profiles+=("$2"); shift 2 ;;
    -r|--region)
      regions+=("$2"); shift 2 ;;
    -R|--all-regions)
      all_regions=1; shift 1 ;;
    -u|--user)
      user="$2"; shift 2 ;;
    -v|--verbose)
      verbose=1; shift 1 ;;
    --) shift 1; break ;;
    *)
      usage_error "Invalid option $1" ;;
  esac
done

if [ "$#" -gt 0 ]; then
  target_name="$1"
  shift
fi

if ! hash aws 2>/dev/null; then
  error 'The aws CLI is required'
fi

query="Reservations[*].Instances[*].["
query+="PrivateDnsName,"
query+="PublicDnsName,"
query+="State.Name,"
query+="Tags[?Key=='Name'] | [0].Value"
query+="]"

filter="Name=instance-state-name,Values=pending,running,shutting-down,stopping"

add_canidates() {
  local profile="$1"
  local region="$2"

  aws_cmd=(aws ec2 describe-instances \
    --output text \
    --query "$query" \
    --filter "$filter" \
  )

  [ -n "$profile" ] && aws_cmd+=(--profile "$profile")
  [ -n "$region" ] && aws_cmd+=(--region "$region")

  while read -r line; do
    private="$(echo "$line" | cut -d$'\t' -f1)"
    public="$(echo "$line" | cut -d$'\t' -f2)"
    state="$(echo "$line" | cut -d$'\t' -f3)"
    name="$(echo "$line" | cut -d$'\t' -f4-)"

    [[ "$name" == *"$target_name"* ]] || continue

    if [ "$dns_type" = 'private' ]; then
      host="$private"
    elif [ "$dns_type" = 'public' ]; then
      host="$public"
    else
      [ -n "$public" ] && host="$public" || host="$private"
    fi

    [ -n "$host" ] || continue

    canidates+=("${host} ${state} ${name}")
  done < <("${aws_cmd[@]}")
}

[ "${#profiles[@]}" = 0 ] && profiles+=('')
[ "${#regions[@]}" = 0 ] && regions+=('')

if [ -n "$all_regions" ]; then
  regions=()
  while read -r region; do
    regions+=("$region")
  done < <( \
    aws ec2 describe-regions --output text --query 'Regions[*].[RegionName]' \
  )
fi

for profile in "${profiles[@]}"; do
  for region in "${regions[@]}"; do
    add_canidates "$profile" "$region"
  done
done

if [ "${#canidates[@]}" -eq 0 ]; then
  error "No hosts found"
elif [ "${#canidates[@]}" -eq 1 ] && [ -z "$list" ]; then
  canidate=(${canidates[@]})
  host="${canidate[0]}"
else
  if [ -z "$choose" ]; then
    number=1
    for canidate in "${canidates[@]}"; do
      parts=($canidate)
      host="${parts[0]}"
      state="${parts[1]}"
      name="${parts[*]:2}"
      [ "${#name}" -gt 40 ] && name="${name:0:37}..."
      [ "${#host}" -gt 45 ] && host="${host:0:27}..."
      [ "$state" = 'running' ] && state=
      printf '%-3s %-40s %-45s %-13s\n' \
	"${number})" "$name" "$host" "$state" >&2
      number=$((number + 1))
    done

    echo -n '> ' >&2
    read -r choose
  fi

  if [ -z "$choose" ]; then
    exit
  fi

  if ! [[ "$choose" =~ ^[0-9]+$ ]]; then
    error "Invalid choice ${choose}"
  fi

  if [ "$choose" -lt 1 ] || [ "$choose" -gt "${#canidates[@]}" ]; then
    error "Choice ${choose} out of range"
  fi

  chosen=(${canidates[(($choose - 1))]})
  host="${chosen[0]}"
fi

if [ -n "$host_only" ]; then
  echo "$host"
  exit
fi

[ -n "$user" ] && host="${user}@${host}"

verbose "Connecting to ${host}"

ssh_cmd=(ssh)
[ -n "$verbose" ] && ssh_cmd+=(-v)
ssh_cmd+=("$host" "$@")
exec "${ssh_cmd[@]}"
